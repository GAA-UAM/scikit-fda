"""Functions for working with arrays of functions."""
from __future__ import annotations

import math
from typing import (
    TYPE_CHECKING,
    Any,
    Iterable,
    Literal,
    Protocol,
    TypeVar,
    Union,
    cast,
    overload,
)

import numpy as np
from array_api_compat import array_namespace

from ...typing._numpy import NDArrayAny, NDArrayFloat, NDArrayInt, NDArrayStr
from ._array_api import Array, DType, NestedArray, Shape
from .extrapolation import ExtrapolationLike

if TYPE_CHECKING:
    from ...representation import FData
    from ...typing._base import DomainRangeLike
    from ...typing._numpy import NDArrayFloat


UfuncMethod = Literal[
    "__call__",
    "reduce",
    "reduceat",
    "accumulate",
    "outer",
    "inner",
]

A = TypeVar('A', bound=Array[Shape, DType])

AcceptedExtrapolation = Union[
    ExtrapolationLike[A],
    None,
    Literal["default"],
]


def _one_grid_to_points(
    axes: GridPointsLike,
    *,
    dim_domain: int,
) -> tuple[NDArrayFloat, Tuple[int, ...]]:
    """
    Convert a list of ndarrays, one per domain dimension, in the points.

    Returns also the shape containing the information of how each point
    is formed.
    """
    from .utils.validation import check_grid_points
    from .utils import cartesian_product
    axes = check_grid_points(axes)
    if axes.shape == ():
        axes.shape = (1,)

    if axes.size != dim_domain:
        raise ValueError(
            f"Length of axes should be {dim_domain}",
        )

    cartesian = cartesian_product(axes)

    # Compute len of each array
    lens = np.vectorize(len)(axes)
    shape = lens.ravel()

    return cartesian, shape


class _SupportsArrayUFunc(Protocol):
    def __array_ufunc__(
        self,
        ufunc: Any,
        method: UfuncMethod,
        *inputs: Any,
        **kwargs: Any,
    ) -> Any:
        pass


T = TypeVar("T", bound=_SupportsArrayUFunc)


class _UnaryUfunc(Protocol):

    def __call__(self, __arg: T) -> T:  # noqa: WPS112
        pass


class EvaluateMethod(Protocol):
    """Evaluation method."""

    def __call__(
        self,
        __eval_points: NDArrayFloat,  # noqa: WPS112
        extrapolation: AcceptedExtrapolation,
        aligned: bool,
    ) -> NDArrayFloat:
        """Evaluate a function."""
        pass


@overload
def _evaluate_grid(
    function,
    axes: Array[InputDType] | NestedArray[InputDType],
    *,
    extrapolation: AcceptedExtrapolation = "default",
    aligned: Literal[True] = True,
) -> NDArrayFloat:
    pass


@overload
def _evaluate_grid(
    function,
    axes: Iterable[GridPointsLike],
    *,
    evaluate_method: EvaluateMethod,
    extrapolation: AcceptedExtrapolation = "default",
    aligned: Literal[False],
) -> NDArrayFloat:
    pass


@overload
def _evaluate_grid(
    function,
    axes: Union[GridPointsLike, Iterable[GridPointsLike]],
    *,
    extrapolation: AcceptedExtrapolation = "default",
    aligned: bool,
) -> NDArrayFloat:
    pass


def _evaluate_grid(  # noqa: WPS234
    function,
    axes: Union[GridPointsLike, Iterable[GridPointsLike]],
    *,
    extrapolation: AcceptedExtrapolation = "default",
    aligned: bool = True,
) -> NDArrayFloat:
    """
    Evaluate the functional object in the cartesian grid.

    This method is called internally by :meth:`evaluate` when the argument
    `grid` is True.

    Evaluates the functional object in the grid generated by the cartesian
    product of the axes. The length of the list of axes should be equal
    than the domain dimension of the object.

    If the list of axes has lengths :math:`n_1, n_2, ..., n_m`, where
    :math:`m` is equal than the dimension of the domain, the result of the
    evaluation in the grid will be a matrix with :math:`m+1` dimensions and
    shape :math:`n_{samples} x n_1 x n_2 x ... x n_m`.

    If `aligned` is false each sample is evaluated in a
    different grid, and the list of axes should contain a list of axes for
    each sample.

    If the domain dimension is 1, the result of the behaviour of the
    evaluation will be the same than :meth:`evaluate` without the grid
    option, but with worst performance.

    Args:
        axes: List of axes to generated the grid where the
            object will be evaluated.
        evaluate_method: Function used to evaluate the functional object.
        n_samples: Number of samples.
        dim_domain: Domain dimension.
        dim_codomain: Codomain dimension.
        extrapolation: Controls the
            extrapolation mode for elements outside the domain range. By
            default it is used the mode defined during the instance of the
            object.
        aligned: If False evaluates each sample
            in a different grid.

    Returns:
        Numpy array with dim_domain + 1 dimensions with
            the result of the evaluation.

    Raises:
        ValueError: If there are a different number of axes than the domain
            dimension.

    """

    # Compute intersection points and resulting shapes
    if aligned:

        #axes = cast(GridPointsLike, axes)

        eval_points, shape = _one_grid_to_points(
            axes, dim_domain=function.dim_domain)

    else:

        axes_per_sample = axes  # cast(Iterable[GridPointsLike], axes)

        axes_per_sample = list(axes_per_sample)

        eval_points_tuple, shape_tuple = zip(
            *[
                _one_grid_to_points(a, dim_domain=function.dim_domain)
                for a in axes_per_sample
            ],
        )

        if len(eval_points_tuple) != function.n_samples:
            raise ValueError(
                "Should be provided a list of axis per sample",
            )

        eval_points = np.asarray(eval_points_tuple)

    # Evaluate the points
    evaluated = function(
        eval_points,
        extrapolation=extrapolation,
        aligned=aligned,
    )

    # Reshape the result
    if aligned:

        res = evaluated.reshape(
            [function.n_samples] + list(shape) + [function.dim_codomain],
        )

    else:

        res = np.asarray([
            r.reshape(list(s) + [function.dim_codomain])
            for r, s in zip(evaluated, shape_tuple)
        ])

    return res


def _average_function_ufunc(
    data: FData,
    ufunc: _UnaryUfunc,
    *,
    domain: DomainRangeLike | None = None,
) -> NDArrayFloat:
    from ...misc.validation import validate_domain_range
    from .. import nquad_vec

    if domain is None:
        domain = data.domain_range
    else:
        domain = validate_domain_range(domain)

    lebesgue_measure = math.prod(
        (
            (iterval[1] - iterval[0])
            for iterval in domain
        ),
    )

    try:
        data_eval = ufunc(data)
    except TypeError:

        def integrand(*args: NDArrayFloat) -> NDArrayFloat:  # noqa: WPS430
            f1 = data(args)[:, :]
            return ufunc(f1)

        return nquad_vec(
            integrand,
            domain,
        ) / lebesgue_measure

    else:
        return data_eval.integrate(domain=domain) / lebesgue_measure


def average_function_value(
    data: FData,
    *,
    domain: DomainRangeLike | None = None,
) -> NDArrayFloat:
    r"""
    Calculate the average function value for each function.

    This is the value that, if integrated over the whole domain of each
    function, has the same integral as the function itself.

    .. math::
        \bar{x} = \frac{1}{\text{Vol}(\mathcal{T})}\int_{\mathcal{T}} x(t) dt

    Args:
        data: Functions where we want to calculate the expected value.
        domain: Integration domain. By default, the whole domain is used.

    Returns:
        ndarray of shape (n_dimensions, n_samples) with the values of the
        expectations.

    See also:
        `Entry on Wikipedia
        <https://en.wikipedia.org/wiki/Mean_of_a_function>`_

    """
    return _average_function_ufunc(data, ufunc=lambda x: x, domain=domain)
